### Canvas API

JavaScript를 통하여 다양한 그림을 그릴 수 있는 공간(Container)을 제공해주며, Bitmap 기반으로 그림을 그려주고, 즉각적으로 그림을 표현한다. API에선 그래프를 그리거나, 사진의 합성 및 조작, 에니메이션 처리를 가능하게 한다. Low Level의 WebGL 도 사용할 수 있으나 구현이 조금 복잡한 감이 있기도 하다.

Canvas 객체는 DOM에 소속되며, 그 내부의 context2D에 구현되는건 Bitmap 이미지이다. 이는 모든 이미지를 다 그리고, 이미지만 남겨놓고 관리하며, SVG는 변화된 부분만 그리기에, 이와는 대조적이다. (변동사항이 있으면 모든 곳을 다 다시 그려야한다.) 따라서, 각각의 Shape를 그리더라도 이들은 객체로써 남는게 아니라 그냥 픽셀이 되어 사라지기에, onClick같은 이벤트를 걸 수가 없다. (Svg는 각각의 이미지가 태그로 객체화 되기에 이들에 이벤트를 걸 수도 있을 것이다.) 따라서 어떤 모양에 이벤트를 거는 것은 직접 좌표값들이 포함되는지에 대한 정보를 가지고 있어야 한다.

Canvas는 펜으로 그림을 그리듯 그림을 그리는 moveTo, LineTo와 일반적인 도형들이 구현되어있다. 또한 패턴과 투명도, 그라디언트와 색상을 넣을수도 있고, 확대 축소도 가능하다. (특정 행동을 한 뒤에 그림을 그려버리는 것이다.) 그리고 회전을 할때는, 이미 그려진 것들을 그냥 두고, context를 회전시킨 뒤에 그림을 그리는 방식이다.

에니메이션을 그릴 수도 있다. 이는 SetTimeout 같은걸 쓰는게 아니라 브라우저에서 직접 지원을 해주는 기능이다. (브라우저마다 다르다) 각각의 프레임별 이미지를 계속해서 업데이트하여  움직이는 것 처럼 보여주는 것이다.

또한 Canvas 테그 내에서 WebGL과 Flash 를 사용할 수 있다.

Nodejs는 Canvas를 구현하는 라이브러리가 많은데, processing.js

### Svg (scalable vector graphics)

W3C 주도로 만들어진 것. 2차원 벡터 그래픽을 표시하기 위한 파일 형식이고, 각각의 엘리먼트는 XML화되어 정의되고 작동된다.

벡터는 확대를 해도 이미지가 깨지지 않는다. 일반적인 PNG같은 것은 각각의 픽셀에 색칠을 해서 사용하는 구조지만, 벡터는 방향값을 가지고 있어, 이미지의 크기와 관계없이 이미지가 깨지지 않고 표시된다.

### 이미지 확장명

https://medium.com/@soeunlee/web를 정리함.

BMP - bit의 맵이고, 압축을 전혀 하지 않는, 그래서 사이즈가 너무 큰 이미지이다. 단 디코딩 할게 없어서 속도가 매우 빠르다고 한다.

GIF - 데이터가 손실되지 않는 무손실 압축을 사용하고, 파일 사이즈는 BMP보다 작다.(좋은 압축 알고리즘) 256가지 컬러로만 저장이 가능하다. 사유는 Indexed color때문.

JPEG - 인간의 눈으로 볼 수 없는 정보를 제거하도록 한다. 손실 압축이고, 똑같은 파일을 JPEG로 저장하면 저장할 수록 점점 손실이 된다. 사진이나 그라데이션이 있는 이미지에 적합하다. (라인이나 로고는 손실이기에 약간 부족하다.) 수천가지의 컬러 파레트를 가지고 있어 다채로운 색상 표현이 용이함

PNG-8 - gif 의 대체품…? 256가지 색상으로만 저장됨.

PNG-24 - 수천가지 컬러 + 무손실 압축이다. BMP보다 파일을 작게 만들지만, 다른 것들보다 파일이 크긴 하다. JPEG 보다 퀄리티가 조금 더 좋긴 한데, 그래도 이미지 용량은 5배가 크기에  좀 더 생각해봐야한다. 회사의 간단한 배너같은것에 쓰이는 경우가 많다. (사이즈와 관계없이 좋은 이미지 퀄리티를 원할 때 사용한다.)

SVG - 의 인기는 점점 증가하고 있는데요. 앞에서 설명한 이미지 타입과는 다른 vector 파일 포맷입니다. 위에서 설명한 것들이 래스터 이미지이죠. Vector 파일 포맷은 실제로 픽셀 대신에 라인과 곡선들로 이루어져 있는데, 백터이미지를 줌인 했을때, 곡선과 선들을 볼수 있다면, 래스터 이미지를 줌 인 햇을 때는, 픽셀들이 보이게 됩니다. XML로 작성되어 편집기로 편집이 가능하다. 단, 래스터 이미지보다는 각각의 방향성을 직접 계산해서 표현하기에 훨신 많은 연산 능력이 필요하다.